// 在运行此代码之前, 请将游戏规则 maxCommandChainLength 增大,
// 经测试, 1000000000 是可行的值. 
// 运行以下的命令来应用此游戏规则: 
// /gamerule maxCommandChainLength 1000000000
// 完成后, 请按照以下的顺序运行命令:
// /function mcscript:init
// /function maze:init
// /function maze:main

// Before running this code, please increase the maxCommandChainLength game rule.
// After testing, 1000000000 is a feasible value.
// Run the following command to apply this game rule:
// /gamerule maxCommandChainLength 1000000000
// Once completed, please run the commands in the following order:
// /function mcscript:init
// /function maze:init
// /function maze:main

let HEIGHT: int = 45;
let WIDTH: int = 45;

let DOWN: int = 1;
let UP: int = 2;
let LEFT: int = 3;
let RIGHT: int = 4;

let AIR: int = 0;
let WALL: int = 1;

let random_num: int = 1;

// 修改 RANDOM_SEED 的值以生成不同的迷宫. 
// Modify the value of RANDOM_SEED to generate different mazes. 
let RANDOM_SEED: int = 7;

let maze: Array<Array<int>> = [[WALL; WIDTH]; HEIGHT];

let x: int = 1;
let y: int = 1;
let blocks: Array<Array<int>> = [[0, 0, 0]; 300];
let blocks_size: int = 0;

fn main() {
    maze[1][1] = AIR;
    find();
    while blocks_size {
        random_num += RANDOM_SEED;
        random_num %= blocks_size;
        let block = blocks[random_num];
        x = block[0];
        y = block[1];
        let dir = block[2];
        if dir == DOWN {
            x += 1;
        } else if dir == RIGHT {
            y += 1;
        } else if dir == LEFT {
            y -= 1;
        } else if dir == UP {
            x -= 1;
        }
        if maze[x][y] == WALL {
            maze[x][y] = AIR;
            maze[block[0]][block[1]] = AIR;
            find();
        }
        random_erase();
    }

    let x = 0;
    while x < WIDTH {
        let z = 0;
        while z < HEIGHT {
            if maze[x][z] == WALL {
                run_command!("fill ~{} ~ ~{} ~{} ~1 ~{} white_concrete", x + 2, z + 2, x + 2, z + 2);
            }
            run_command!("setblock ~{} ~-1 ~{} white_concrete", x + 2, z + 2);
            z += 1;
        }
        x += 1;
    }
}

fn find() {
    if x + 1 < WIDTH - 1 && maze[x + 1][y] == WALL {
        push(x + 1, y, DOWN);
    }
    if y + 1 < HEIGHT - 1 && maze[x][y + 1] == WALL {
        push(x, y + 1, RIGHT);
    }
    if x - 1 > 0 && maze[x - 1][y] == WALL {
        push(x - 1, y, UP);
    }
    if y - 1 > 0 && maze[x][y - 1] == WALL {
        push(x, y - 1, LEFT);
    } 
}

fn push(x: int, y: int, dir: int) {
    blocks[blocks_size] = [x, y, dir];
    blocks_size += 1;
}

fn random_erase() {
    let i = random_num;
    while i + 1 < blocks_size {
        blocks[i] = blocks[i + 1];
        i += 1;
    }
    blocks_size -= 1;
}