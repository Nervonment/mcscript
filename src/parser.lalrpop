use mcscript::ast::{
    Program, FuncDef, Block, BlockItem, Stmt, Decl,
    exp::{ Exp, UnaryOp, BinaryOp },
};

grammar;

// lexer
match {
    // skip spaces & comments
    r"\s*" => {},
    r"//.*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
    _
}

pub Program: Program = <func_def: FuncDef> => Program { <> };

FuncDef: FuncDef = {
    "fn" <ident: Ident> "(" ")"  <block: Block> => FuncDef { <> }
}

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

Block: Block = "{" <items: BlockItem*> "}" => Block(<>);

BlockItem: BlockItem = {
    Decl => BlockItem::Decl(<>),
    Stmt => BlockItem::Stmt(<>),
}

Decl: Decl = {
    "let" <ident: Ident> "=" <init_value: Exp> ";" => Decl{ <> }
}

Stmt: Stmt = {
    ReturnStmt,
    AssignStmt,
    Block => Stmt::Block(<>),
    // IfElseStmt,
}

ReturnStmt: Stmt = {
    "return" <return_value: Exp> ";" => Stmt::Return { <> }
}

AssignStmt: Stmt = {
    <ident: Ident> "=" <new_value: Exp> ";" => Stmt::Assign{ <> }
}

// IfElseStmt: Stmt = {
//     "if" <exp: Exp> <if_branch: Block> 
// }

Number: i32 = IntConst;

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

Exp: Box<Exp> = EqExp;

PrimaryExp: Box<Exp> = {
    Number => Box::new(Exp::Number(<>)),
    Ident => Box::new(Exp::Variable(<>)),
    "(" <Exp> ")",
}

UnaryExp: Box<Exp> = {
    <op: UnaryOp> <exp: UnaryExp> => {
        Box::new(Exp::UnaryExp(op, exp))
    },
    PrimaryExp,
}

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Positive,
    "-" => UnaryOp::Negative,
}

MulExp: Box<Exp> = {
    <lhs: MulExp> <op: MulOp> <rhs: UnaryExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    UnaryExp,
}

MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod
}

AddExp: Box<Exp> = {
    <lhs: AddExp> <op: AddOp> <rhs: MulExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    MulExp,
}

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

RelExp: Box<Exp> = {
    <lhs: RelExp> <op: RelOp> <rhs: AddExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    AddExp,
}

RelOp: BinaryOp = {
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
}

EqExp: Box<Exp> = {
    <lhs: EqExp> <op: EqOp> <rhs: RelExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    RelExp,
}

EqOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
}
