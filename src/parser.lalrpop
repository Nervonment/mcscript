use mcscript::ast::{
    Program, FuncDef, Block, BlockItem, Stmt, Decl, FuncParam, 
    exp::{ Exp, UnaryOp, BinaryOp },
};

grammar;

// lexer
match {
    // skip spaces & comments
    r"\s*" => {},
    r"//.*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
    _
}

pub Program: Program =<func_defs: (<FuncDef>)*> => Program { <> };

FuncDef: FuncDef = {
    "fn" <ident: Ident> "(" <param: FuncParam?> <mut params: ("," <FuncParam>)*> ")" <block: Block> => {
        if param.is_some() {
            params.insert(0, param.unwrap());
        }
        FuncDef { ident, params, block }
    }
}

FuncParam: FuncParam = <ident: Ident> => FuncParam { <> };

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

Block: Block = "{" <items: BlockItem*> "}" => Block(<>);

BlockItem: BlockItem = {
    Decl => BlockItem::Decl(<>),
    Stmt => BlockItem::Stmt(<>),
}

Decl: Decl = {
    "let" <ident: Ident> "=" <init_value: Exp> ";" => Decl{ <> }
}

Stmt: Stmt = {
    ReturnStmt,
    AssignStmt,
    OpAssignStmt,
    Block => Stmt::Block(<>),
    IfElseStmt,
    WhileStmt,
    "break" ";" => Stmt::Break,
    "continue" ";" => Stmt::Continue,
    <Exp> ";" => Stmt::Exp(<>),
}

ReturnStmt: Stmt = {
    "return" <return_value: Exp> ";" => Stmt::Return { <> }
}

AssignStmt: Stmt = {
    <ident: Ident> "=" <new_value: Exp> ";" => Stmt::Assign { <> }
}

OpAssignStmt: Stmt = {
    <ident: Ident> "+=" <value: Exp> ";" => Stmt::Assign { ident: ident.clone(), new_value: Box::new(Exp::BinaryExp(BinaryOp::Add, Box::new(Exp::Variable(ident)), value)) },
    <ident: Ident> "-=" <value: Exp> ";" => Stmt::Assign { ident: ident.clone(), new_value: Box::new(Exp::BinaryExp(BinaryOp::Sub, Box::new(Exp::Variable(ident)), value)) },
    <ident: Ident> "*=" <value: Exp> ";" => Stmt::Assign { ident: ident.clone(), new_value: Box::new(Exp::BinaryExp(BinaryOp::Mul, Box::new(Exp::Variable(ident)), value)) },
    <ident: Ident> "/=" <value: Exp> ";" => Stmt::Assign { ident: ident.clone(), new_value: Box::new(Exp::BinaryExp(BinaryOp::Div, Box::new(Exp::Variable(ident)), value)) },
    <ident: Ident> "%=" <value: Exp> ";" => Stmt::Assign { ident: ident.clone(), new_value: Box::new(Exp::BinaryExp(BinaryOp::Mod, Box::new(Exp::Variable(ident)), value)) },
}

IfElseStmt: Stmt = {
    "if" <exp: Exp> <if_branch: Block> => Stmt::IfElse { exp, if_branch: if_branch, else_branch: None },
    "if" <exp: Exp> <if_branch: Block> "else" <else_branch: Block> => Stmt::IfElse { exp, if_branch, else_branch: Some(else_branch)},
    "if" <exp: Exp> <if_branch: Block> "else" <else_branch: IfElseStmt> => Stmt::IfElse { exp, if_branch, else_branch: Some(Block(vec![BlockItem::Stmt(else_branch)])) },
}

WhileStmt: Stmt = {
    "while" <exp: Exp> <body: Block> => Stmt::While { <> }
}

Number: i32 = IntConst;

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

Exp: Box<Exp> = EqExp;

PrimaryExp: Box<Exp> = {
    Number => Box::new(Exp::Number(<>)),
    Ident => Box::new(Exp::Variable(<>)),
    <namespace: NamespacePrefix?> <func_ident: Ident> "(" <arg: Exp?> <mut args: ("," <Exp>)*> ")" => {
        if arg.is_some() {
            args.insert(0, arg.unwrap());
        }
        Box::new(Exp::FuncCall { namespace, func_ident, arguments: args })
    },
    "(" <Exp> ")",
}

NamespacePrefix: String = <Ident> "::";

FuncArg: Box<Exp> = Exp;

UnaryExp: Box<Exp> = {
    <op: UnaryOp> <exp: UnaryExp> => {
        Box::new(Exp::UnaryExp(op, exp))
    },
    PrimaryExp,
}

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Positive,
    "-" => UnaryOp::Negative,
}

MulExp: Box<Exp> = {
    <lhs: MulExp> <op: MulOp> <rhs: UnaryExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    UnaryExp,
}

MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod
}

AddExp: Box<Exp> = {
    <lhs: AddExp> <op: AddOp> <rhs: MulExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    MulExp,
}

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}

RelExp: Box<Exp> = {
    <lhs: RelExp> <op: RelOp> <rhs: AddExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    AddExp,
}

RelOp: BinaryOp = {
    "<" => BinaryOp::Lt,
    ">" => BinaryOp::Gt,
    "<=" => BinaryOp::Le,
    ">=" => BinaryOp::Ge,
}

EqExp: Box<Exp> = {
    <lhs: EqExp> <op: EqOp> <rhs: RelExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    RelExp,
}

EqOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
}
