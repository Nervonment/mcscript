use mcscript::ast::{
    Program, FuncDef, Block, BlockItem, Stmt,
    exp::{ Exp, UnaryOp, BinaryOp },
};

grammar;

// lexer
match {
    // skip spaces & comments
    r"\s*" => {},
    r"//.*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
    _
}

pub Program: Program = <func_def: FuncDef> => Program { <> };

FuncDef: FuncDef = {
    "fn" <ident: Ident> "(" ")"  <block: Block> => FuncDef { <> }
}

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

Block: Block = "{" <items: BlockItem*> "}" => Block(<>);

BlockItem: BlockItem = {
//    Decl => BlockItem::Decl(<>),
    Stmt => BlockItem::Stmt(<>),
}

Stmt: Stmt = {
    ReturnStmt,
}

ReturnStmt: Stmt = {
    "return" <return_value: Exp> ";" => Stmt::Return { <> }
}


Number: i32 = IntConst;

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

Exp: Box<Exp> = AddExp;

PrimaryExp: Box<Exp> = {
    Number => Box::new(Exp::Number(<>)),
    "(" <Exp> ")",
}

UnaryExp: Box<Exp> = {
    <op: UnaryOp> <exp: UnaryExp> => {
        Box::new(Exp::UnaryExp(op, exp))
    },
    PrimaryExp,
}

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Positive,
    "-" => UnaryOp::Negative,
}

MulExp: Box<Exp> = {
    <lhs: MulExp> <op: MulOp> <rhs: UnaryExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    UnaryExp,
}

MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod
}

AddExp: Box<Exp> = {
    <lhs: AddExp> <op: AddOp> <rhs: MulExp> => Box::new(Exp::BinaryExp(op, lhs, rhs)),
    MulExp,
}

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}